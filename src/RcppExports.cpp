// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <RcppEigen.h>
#include <Rcpp.h>

using namespace Rcpp;

// solve_LLT
Eigen::MatrixXd solve_LLT(Eigen::Map<Eigen::MatrixXd> A, Eigen::Map<Eigen::MatrixXd> b);
RcppExport SEXP _sanic_solve_LLT(SEXP ASEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_LLT(A, b));
    return rcpp_result_gen;
END_RCPP
}
// solve_LDLT
Eigen::MatrixXd solve_LDLT(Eigen::Map<Eigen::MatrixXd> A, Eigen::Map<Eigen::MatrixXd> b);
RcppExport SEXP _sanic_solve_LDLT(SEXP ASEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_LDLT(A, b));
    return rcpp_result_gen;
END_RCPP
}
// solve_SLLT
Eigen::MatrixXd solve_SLLT(Eigen::MappedSparseMatrix<double> A, Eigen::Map<Eigen::MatrixXd> b);
RcppExport SEXP _sanic_solve_SLLT(SEXP ASEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::MappedSparseMatrix<double> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_SLLT(A, b));
    return rcpp_result_gen;
END_RCPP
}
// solve_SLDLT
Eigen::MatrixXd solve_SLDLT(Eigen::MappedSparseMatrix<double> A, Eigen::Map<Eigen::MatrixXd> b);
RcppExport SEXP _sanic_solve_SLDLT(SEXP ASEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::MappedSparseMatrix<double> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_SLDLT(A, b));
    return rcpp_result_gen;
END_RCPP
}
// solve_PPLU
Eigen::MatrixXd solve_PPLU(Eigen::Map<Eigen::MatrixXd> A, Eigen::Map<Eigen::MatrixXd> b);
RcppExport SEXP _sanic_solve_PPLU(SEXP ASEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_PPLU(A, b));
    return rcpp_result_gen;
END_RCPP
}
// solve_SLU
Eigen::MatrixXd solve_SLU(Eigen::MappedSparseMatrix<double> A, Eigen::Map<Eigen::MatrixXd> b);
RcppExport SEXP _sanic_solve_SLU(SEXP ASEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::MappedSparseMatrix<double> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_SLU(A, b));
    return rcpp_result_gen;
END_RCPP
}
// solve_HQR
Eigen::MatrixXd solve_HQR(Eigen::Map<Eigen::MatrixXd> A, Eigen::Map<Eigen::MatrixXd> b);
RcppExport SEXP _sanic_solve_HQR(SEXP ASEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_HQR(A, b));
    return rcpp_result_gen;
END_RCPP
}
// solve_CPHQR
Eigen::MatrixXd solve_CPHQR(Eigen::Map<Eigen::MatrixXd> A, Eigen::Map<Eigen::MatrixXd> b);
RcppExport SEXP _sanic_solve_CPHQR(SEXP ASEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_CPHQR(A, b));
    return rcpp_result_gen;
END_RCPP
}
// solve_SQR
Eigen::MatrixXd solve_SQR(Eigen::MappedSparseMatrix<double> A, Eigen::Map<Eigen::MatrixXd> b);
RcppExport SEXP _sanic_solve_SQR(SEXP ASEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::MappedSparseMatrix<double> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_SQR(A, b));
    return rcpp_result_gen;
END_RCPP
}
// solve_DTNSBCGST
Eigen::MatrixXd solve_DTNSBCGST(Eigen::MappedSparseMatrix<double> A, Eigen::Map<Eigen::MatrixXd> b, Eigen::Map<Eigen::MatrixXd> x0, double tol, int iter, bool verbose);
RcppExport SEXP _sanic_solve_DTNSBCGST(SEXP ASEXP, SEXP bSEXP, SEXP x0SEXP, SEXP tolSEXP, SEXP iterSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::MappedSparseMatrix<double> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type x0(x0SEXP);
    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
    Rcpp::traits::input_parameter< int >::type iter(iterSEXP);
    Rcpp::traits::input_parameter< bool >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_DTNSBCGST(A, b, x0, tol, iter, verbose));
    return rcpp_result_gen;
END_RCPP
}
// solve_BCGST
Eigen::MatrixXd solve_BCGST(Eigen::MappedSparseMatrix<double> A, Eigen::Map<Eigen::MatrixXd> b, Eigen::Map<Eigen::MatrixXd> x0, double tol, int iter, bool verbose);
RcppExport SEXP _sanic_solve_BCGST(SEXP ASEXP, SEXP bSEXP, SEXP x0SEXP, SEXP tolSEXP, SEXP iterSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::MappedSparseMatrix<double> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type x0(x0SEXP);
    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
    Rcpp::traits::input_parameter< int >::type iter(iterSEXP);
    Rcpp::traits::input_parameter< bool >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_BCGST(A, b, x0, tol, iter, verbose));
    return rcpp_result_gen;
END_RCPP
}
// solve_CGLS
Eigen::VectorXd solve_CGLS(Eigen::MappedSparseMatrix<double> A, Eigen::Map<Eigen::MatrixXd> b, Eigen::Map<Eigen::MatrixXd> x0, double tol, int iter, bool verbose);
RcppExport SEXP _sanic_solve_CGLS(SEXP ASEXP, SEXP bSEXP, SEXP x0SEXP, SEXP tolSEXP, SEXP iterSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::MappedSparseMatrix<double> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type x0(x0SEXP);
    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
    Rcpp::traits::input_parameter< int >::type iter(iterSEXP);
    Rcpp::traits::input_parameter< bool >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_CGLS(A, b, x0, tol, iter, verbose));
    return rcpp_result_gen;
END_RCPP
}
// solve_CG
Eigen::VectorXd solve_CG(Eigen::MappedSparseMatrix<double> A, Eigen::Map<Eigen::MatrixXd> b, Eigen::Map<Eigen::MatrixXd> x0, double tol, int iter, int verbose);
RcppExport SEXP _sanic_solve_CG(SEXP ASEXP, SEXP bSEXP, SEXP x0SEXP, SEXP tolSEXP, SEXP iterSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::MappedSparseMatrix<double> >::type A(ASEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type b(bSEXP);
    Rcpp::traits::input_parameter< Eigen::Map<Eigen::MatrixXd> >::type x0(x0SEXP);
    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
    Rcpp::traits::input_parameter< int >::type iter(iterSEXP);
    Rcpp::traits::input_parameter< int >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(solve_CG(A, b, x0, tol, iter, verbose));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_sanic_solve_LLT", (DL_FUNC) &_sanic_solve_LLT, 2},
    {"_sanic_solve_LDLT", (DL_FUNC) &_sanic_solve_LDLT, 2},
    {"_sanic_solve_SLLT", (DL_FUNC) &_sanic_solve_SLLT, 2},
    {"_sanic_solve_SLDLT", (DL_FUNC) &_sanic_solve_SLDLT, 2},
    {"_sanic_solve_PPLU", (DL_FUNC) &_sanic_solve_PPLU, 2},
    {"_sanic_solve_SLU", (DL_FUNC) &_sanic_solve_SLU, 2},
    {"_sanic_solve_HQR", (DL_FUNC) &_sanic_solve_HQR, 2},
    {"_sanic_solve_CPHQR", (DL_FUNC) &_sanic_solve_CPHQR, 2},
    {"_sanic_solve_SQR", (DL_FUNC) &_sanic_solve_SQR, 2},
    {"_sanic_solve_DTNSBCGST", (DL_FUNC) &_sanic_solve_DTNSBCGST, 6},
    {"_sanic_solve_BCGST", (DL_FUNC) &_sanic_solve_BCGST, 6},
    {"_sanic_solve_CGLS", (DL_FUNC) &_sanic_solve_CGLS, 6},
    {"_sanic_solve_CG", (DL_FUNC) &_sanic_solve_CG, 6},
    {NULL, NULL, 0}
};

RcppExport void R_init_sanic(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
